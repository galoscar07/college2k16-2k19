<html>
<body>

<span align="center"><b>String examples. Interrupts. Multi-module programming</b></span><br/>
<p><b>String examples</b></p>
<pre>
Ex.1. Being given 2 strings of words, "s" and "t", build a new string of bytes which should contain
the least significant byte of each word from string "s" followed by the most significant byte of
each word from string "t". Then sort ascending the resulted byte string.


assume cs:code, ds:data
data segment
        s   dw   2345h, 0a5h, 368h, 3990h
        len_s   equ   ($-s)/2
        t   dw   4h, 2655h, 10
        len_t   equ   ($-t)/2
        len   equ   len_s+len_t 
        u   db   len dup (?)

data ends
code segment
start:
        mov ax, data
        mov ds, ax
        
	; first we copy the low bytes of the words from string "s" into string "u"
	; put the address of "s" in DS:SI and the address of "u" in ES:DI

        push ds
        pop es
        lea si, s
        lea di, u
        cld
        mov cx, len_s 

repeta: 
        lodsw			; AL=low byte of current word; AH=high byte of the current word
        stosb   		; we need only the low word (AL)
        loop repeta

	; then copy the high bytes of words from string "t" into string "u"
	; put the address of "t" in DS:SI
	; ES:DI is ok.

        lea si, t
        mov cx, len_t

repeta1:
        lodsw
        xchg al, ah		; now we need the high byte (AH) so we put it in AL 
				; in order to move it to the destination string (using stosb in the following line)
        stosb
        loop repeta1

        ; we sort ascending the string of bytes "u" using bubblesort 
        mov dx, 1	; if DX=1 then the string is not yet sorted

repeta2:
        cmp dx, 0
        je sfarsit		; if DX=0, string is sorted, so exit loop
        lea si, u
        mov dx, 0
        mov cx, len-1           
                

        repeta3: 
		; this loop parses the string interchanging values of pairs of bytes which are not in ascending order

		; compare elements ds:[si] with ds:[si+1]
                mov al, byte ptr ds:[si]                ; is equivalent to: mov al, [si]
                cmp al, byte ptr ds:[si+1]              ; is equivalent to: cmp al, [si+1]
                jbe iteratie_noua

                ; if they are not ordered ascending, interchange values ds:[si] and ds:[si+1]
                mov ah, byte ptr ds:[si+1]
                mov byte ptr ds:[si], ah
                mov byte ptr ds:[si+1], al
                mov dx, 1	; string is not sorted yet

                iteratie_noua:
                              inc si
                              loop repeta3
                              jmp repeta2               


sfarsit:
        mov ax, 4C00h
        int 21h
code ends
end start


Ex.2. Se da un sir de valori numerice intregi reprezentate pe dublucuvinte.
Sa se determine suma cifrelor numarului multiplilor de 8 din sirul 
octetilor inferiori ai cuvintelor superioare din elementele sirului
de dublu cuvinte.

assume ds: data, cs: code
data segment
        sir dd 12300011h, 0abcd0h, 2218acach, 7a082AE3h, 0c820ddd1h, 7828ddd1h, 0c8d8ddd1h, 0c8b0ddd1h, 7260ddd1h, 2a70ddd1h, 7850ddd1h, 0c840ddd1h
        len equ ($-sir)/4
        opt db 8
        zece db 10
        suma db 0
data ends
code segment
start:
        mov ax, data
        mov ds, ax
        mov si, offset sir      ;put the adress of "sir" in DS:SI
        cld                         
        mov cx, len
        mov bx, 0               ;BX will store the number of bytes which are multiple of 8
again:
        lodsw                   ;in AX we have the low word of the current doubleword of "sir"                      
        lodsw                   ;we are only interested in the high word of the current doubleword
        mov ah, 0               ;we are only interested in the low byte of the high word
        div opt                 ;check whether AL divides to 8
        cmp ah, 0
        jnz nonmultiplu
        inc bx			; increment number of multiples

nonmultiplu:
        loop again

        ;obtain the digits in base 10 of bx, by continuously dividing it to 10 and keep the remainder

        mov ax, bx
transf:
        div zece    
        add suma, ah		; add the digit (remainder) to sum
        cmp al, 0
        jz gata			; stop when quotient is zero
        mov ah, 0
        jmp transf

gata:   

        mov ax, 4C00h
        int 21h 
code ends
end start



</pre>


<p><b>Interrupts</b></p>

<pre>
Interrupts are electrical signals which signalizes the occurrence of an event in the computing system's life (ex. the user pressed a key, a new packet arrived from the network etc.).

An interrupt can be generated by:
- hardware devices: keyboard, mouse, network card, hard disk, CPU etc.
- software instruction: instruction "int" instructs the CPU to generate an interrupt


Interrupts are always detected and handled by the CPU. If the CPU detects an interrupt, it does the following things:
- suspend the execution of the current program
- execute a function named Interrupt Handling Routine (IHR)
- eventually, resume the execution of the suspended program


Sometimes, the IHR of an interrupt executes several functionalities depending on the value of a certain register (usually AH). In this case, we say that the interrupt has several functions. Ex. the interrupt 21h contains the DOS function.
Ex. calling function 4ch of interrupt 21h which ends the current program and frees the ocupied memory:

mov ax, 4c00h
int 21h

All you need to do for the interrupts laboratory is to find in Norton Guide the interrupt which does what your problem/task demands and call (issue) that interrupt using the instruction "int".



Ex.1. Read the name of a file from the standard input device and delete that file.

assume cs:code, ds:data
data segment
        msg db 'Name of the file: $'
	fileName db 12,?,13 dup (?)
data ends
code segment
start:
        mov ax, data
        mov ds, ax

	; print msg using function 09h, int 21h
        mov ah, 09h		; put the name of the function in AH
        mov dx, offset msg	; in DS:DX there must be a pointer to the message that will be written on the screen 
				; (this string must end with '$')
        int 21h			; issue (generate) interrupt 21h

        ; read from standard input the name of the file using function 0ah, int 21h
        mov ah, 0ah		; put in AH tthe function name
	mov dx, offset fileName ; before issuing the interrupt, in DS:DX there must be a pointer to a string with the following structure:
				; - at offset 0 we must set the maximum number of characters to be read
				; - at offset 1 it does not matter what we put because the IHR of interrupt 21h will
				;   store the actual number of read characters
				; - starting at offset 2, the IHR will store the ASCII code of the read characters

        int 21h			; issue the interrupt
        ; after reading, the name of the file will be stored at the address fileName+2
        ; at the address fileName + 1 the length (in bytes) of the filename will be stored by the IHR (Interrupt Handling Routine)

	; for example, if the user typed "a.txt", the fileName string will contain the following:
	;           12,5,'a','.','t','x','t',?,?,?,?,?,?,?,?


        ; transform the filename in an ASCIIZ string
        mov bl, fileName[1]
        mov bh, 0
        add bx, offset fileName
        add bx, 2
        mov byte ptr [bx], 0            ; put 0 at the end of the filename (so that the name becomes 'a.txt'0 in our example)


	; delete the file using function 41h of interrupt 21h
	mov ah, 41h
	lea dx, fileName+2	; the name of the file starts at offset 2 in the variable "fileName"
	int 21h			; issue interrupt 21h

	mov ax, 4c00h
	int 21h
code ends
end start


Ex.2. Read the name of a file from the standard input device. Print the contents of this file
on the screen.


assume cs:code, ds:data
data segment
	msg db 'Name of the file: $'
	fileName db 12,?,13 dup (?)
	buffer db 21 dup (?)
	openErrorMsg db 'The File does not exist.$'
	readErrorMsg db 'Can not read from file.$'
	handler dw 0
data ends
code segment
start:
	mov ax, data
	mov ds, ax

	; print msg using function 09h, int 21h
	mov ah, 09h
  	mov dx, offset msg
	int 21h 

	; read from standard input the name of the file using function 0ah, int 21h
	mov ah, 0ah
	mov dx, offset fileName
	int 21h
	; after reading, the name of the file will be stored at the address fileName+2 
	; at the address fileName + 1 the length (in bytes) of the filename will be stored by the IHR (Interrupt Handling Routine)

	; transform the filename in an ASCIIZ string
	mov bl, fileName[1]
	mov bh, 0
	add bx, offset fileName
	add bx, 2
	mov byte ptr [bx], 0		; put 0 at the end of the filename

	; open the file using function 3dh, int 21h
	mov ah, 3dh
	mov al, 0 ; open file for reading  
	mov dx, offset fileName+2
	int 21h		; function 3dh of interrupt 21h will open the file whose name is at the address pointed by DS:DX.
			; This function returns a handle (a number which will be used in other functions related to this file)
			; or it sets CF=1 if there is an error (for example, if the file is not found).

	jc openError ; if CF=1 we have an error opening file
	mov handler, ax ; save the ID (handler) of the opened file in handler

	; while we did not reach the end of the file, keep reading 20 bytes from the file and display them on the screen
	goOn:
		; read maximum 20 characters from the file using function 3fh of interrupt 21h
		mov ah, 3fh
		mov bx, handler		; BX must contain the handle of an open file
		mov dx, offset buffer	; read in buffer
		mov cx, 20 ; we read maxim 20 characters
		int 21h

		jc readError

		; if no error occured the function 3dh returns in ax the number of read bytes
		; save the number of the read bytes and prepare the string for printing on the screen 
		mov si, ax
		mov buffer[si], '$'

		; print on the screen what we have read
		mov ah, 09h
		int 21h
	    	cmp si, 20
          	je goOn ; if we have read exactly 20 bytes it means we have not reached the end of the file
     	    	jmp endPrg ; skeep error handling ..
		openError:
			; print openErrorMsg on the screen using function 09h of interrupt 21h
			mov ah, 09h
			mov dx, offset openErrorMsg
			int 21h
			jmp endPrg

		readError:
			 ; print readErrorMsg on the screen using function 09h of interrupt 21h
			mov ah, 09h
			mov dx, offset readErrorMsg
			int 21h

		endPrg:
			; close the file using function 3eh of interrupt 21h
			mov ah, 3eh
			mov bx, handler
			int 21h

	mov ax,4c00h
	int 21h

code ends
end start


Ex.3. Write a program which prints on the screen the values, in base 10, of the registers AX and BX.
 

Rezolvare: Because there is no interrupt whose IHR can print (or read) a number
in base 10, we have to use function 02h of interrupt 21h which prints a
character on the screen or we can use function 09h of interrupt 21h which prints
a string on the screen. In order to get from a number (ex. 2345 in base 10) to
a string of characters which can be printed on the screen (ex. string '2','4','3','5')
we will successively devide the number and the obtained quotients to 10
and will hold the remainders which represent the digits of the number.

 

assume cs:code, ds:data
data segment
	LinieNoua db 10,13,'$'
	zece dw 10
data segment
code segment

	AfisBaza10 PROC
		; define a procedure which prints the value of the AX register, in base 10, on the screen
		cmp ax, 0
 		jge pozitiv 
		; else, if the number is negative print the character '-' using function 02h a int 21h
		push ax
		mov ah, 02h
		mov dl, '-'
		int 21h
		pop ax
		neg ax ; ax:= -ax

		pozitiv:
		; in order to avoid overflows, we will always divide DX:AX to 10 (not just AX). We
		; keep dividing to 10 and store the remainders (the digits) on the stack. When we will
		; pop the digits off the stack they will be in the reverse order which is the correct order

		mov cx, 0 ; cx will hold the number of digits placed on the stack
		repeta:
			mov dx, 0
			div zece
			push dx
			inc cx
			cmp ax, 0
			ja repeta ; if quotient>0 jmp repeta 

		; now we pop each digit off the stack and print it on the screen using function 02h of int 21h

		scoate:
			pop dx
			; the remainder, that is the digit, is in DL (because it is a number between 0 and 10); DH will be zero
			add dl, '0' ; obtain the character corresponding to the digit
			mov ah, 02
			int 21h
			loop scoate
		ret 	; return from procedure
AfisBaza10 ENDP


start: 
		mov ax, data
		mov ds, ax

		mov ax, 2435
		; print the value of AX by calling the procedure AfisBaza10
		call AfisBaza10

		; jump to a new line on the screen
		mov ah, 09h
		lea dx, LinieNoua
		int 21h

		mov ax, bx
		; print the value of AX by calling the procedure AfisBaza10
		call AfisBaza10
 
		mov ax, 4c00h
		int 21h
code ends
end start

</pre>
 


<p><b>Multi-module programming asm-asm</b></p>
<br/><br/>

Multi-module programming = writting a program which is formed by at least 2 modules: 
<ul>
<li>main module (caller code)</li>
<li>secondary module (called code), contains a procedure which will be called by the main module</li>
</ul>

<p>Useful directives:<br/>
<b>PUBLIC</b> symbol    : exports "symbol" which is defined in the current module in order to be used in other modules<br/><br/>
<b>EXTRN</b> symbol: type   : imports "symbol" which is defined in an external module in order to be used in the current module; type
can be: BYTE, WORD, DWORD, NEAR, FAR, PROC, ABS (constant, equ).<br/><br/>
<b>GLOBAL</b> symbol    : does the same thing as PUBLIC and EXTRN together.
</p>

<pre>
Ex.3. Write a program which concatenates 2 strings by calling a procedure which is written in an external module.
Then the main module should display the resulted string.

Module main.asm:

assume cs:code, ds:data
data segment
	s1 db 'Good ', 0
	s2 db 'morning!', 0
	result db 30 dup(?)
data ends
PUBLIC result
EXTRN Concat:PROC
code segment
start:
	mov ax, data
	mov ds, ax

	mov ax, offset s1
	mov bx, offset s2
	call Concat

	mov ah, 09h
	lea dx, result
	int 21h

	mov ax, 4c00h
	int 21h
code ends
end start


Module secundar.asm:

assume cs:code, ds:data

data segment
data ends

EXTRN result:BYTE
PUBLIC Concat

code segment
	Concat PROC 
		push ds
		pop es
		; in AX we have offset s1 and in BX we have offset s2
		mov di, offset result
		mov si, ax

		repeta:
			lodsb
			cmp al, 0
			je cont
			stosb
			jmp repeta

		cont:
			mov si, bx
		
		repeta1:
			lodsb
			cmp al, 0
			je dupa
			stosb
			jmp repeta1

		dupa:
			mov al, '$'
			stosb			

		ret
	Concat ENDP

code ends
end

Obtaining the executable file:
TASM main.asm
TASM secundar.asm
TLINK main+secundar


</pre>

</body>
</html>
